# Electron Desktop Client Migration Plan

## Overview

Migrate from MonsterUI/FastHTML web client to Electron desktop app with React + TypeScript + Tailwind CSS + shadcn/ui.

**Why Electron?**
- Developer tool use case (local API, MCP integration, observability)
- Native desktop experience (system integration, file access)
- No hosting/deployment complexity
- Cross-platform from single codebase

**No Backwards Compatibility**: Design the best architecture without MonsterUI constraints. Breaking changes encouraged.

---

## Reference Documentation

Agent should review before starting:
- **Electron Docs**: https://www.electronjs.org/docs/latest/tutorial/quick-start
- **shadcn/ui**: https://ui.shadcn.com/docs
- **React SSE Pattern**: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
- **Zustand**: https://docs.pmnd.rs/zustand/getting-started/introduction

---

## Tech Stack

- **Electron**: Desktop wrapper
- **React 18**: UI framework
- **TypeScript**: Type safety (strict mode)
- **Vite**: Build tool (fast, modern)
- **Tailwind CSS**: Utility-first styling
- **shadcn/ui**: Component library (accessible, composable)
- **Zustand**: State management (simpler than Redux)

---

## Milestone 1: Project Scaffolding

**Goal**: Set up Electron + React + TypeScript + Vite with hot reload working.

**Success Criteria**:
- `npm run dev` starts Electron with React hot-reload
- `npm run build` produces distributable app
- TypeScript strict mode enabled
- Tailwind CSS processing works
- Basic "Hello World" renders

**Key Changes**:
- Create `desktop-client/` directory with package.json
- Configure Vite for Electron (base path, output directories)
- Set up Electron main process (window creation, security settings)
- Set up preload script (secure IPC bridge)
- Configure TypeScript (strict mode, React JSX)
- Configure Tailwind CSS

**Testing**: Manual - verify dev mode works, hot reload works, TypeScript catches errors.

**Dependencies**: None

**Risks**: Electron security settings (ensure nodeIntegration: false), Vite config for file:// protocol.

---

## Milestone 2: API Types & HTTP Client

**Goal**: Define type-safe OpenAI-compatible API client with SSE streaming support.

**Success Criteria**:
- TypeScript types match OpenAI API (`ChatCompletionRequest`, `ChatCompletionChunk`, `ReasoningEvent`)
- API client class handles POST to `/v1/chat/completions`
- SSE parser handles `data:` prefix and `[DONE]` signal
- Basic React hook (`useStreamingChat`) manages SSE lifecycle
- Demo component shows streaming working

**Key Changes**:
- Define types in `src/types/openai.ts` (based on `api/models.py`)
- Create API client in `src/lib/api-client.ts` with async generator for streaming
- Create SSE parser in `src/lib/sse-parser.ts`
- Create React hook in `src/hooks/useStreamingChat.ts`

**Testing**:
- Unit tests for SSE parser (valid events, [DONE], malformed JSON)
- Integration tests for hook (mock fetch, verify state updates)
- Manual test with actual API

**Dependencies**: Milestone 1

**Risks**: SSE parsing complexity (ReadableStream API), type alignment with actual API responses.

---

## Milestone 3: UI Component Library

**Goal**: Install shadcn/ui and configure theme.

**Success Criteria**:
- shadcn/ui CLI configured
- Core components installed (Button, Card, Textarea, ScrollArea, Accordion, Separator)
- Theme matches project aesthetic (optional: blue theme like MonsterUI)
- Demo page shows all components working

**Key Changes**:
- Run `npx shadcn-ui@latest init`
- Install components via CLI
- Customize Tailwind config (colors for reasoning events: blue/purple/orange/green)
- Create demo page showing all variants

**Testing**: Manual - visual verification, keyboard navigation, accessibility check.

**Dependencies**: Milestone 1 (Tailwind must be set up)

**Risks**: Path aliases (@/*) must be configured in tsconfig and vite.config.

---

## Milestone 4: Chat Message Components

**Goal**: Build React components for messages, reasoning steps, streaming indicator.

**Success Criteria**:
- `ChatMessage` component renders user/assistant/system messages
- `ReasoningStep` component displays reasoning events with type-specific icons/colors
- `ReasoningAccordion` shows collapsible reasoning tree
- `StreamingIndicator` shows blinking cursor
- Demo page shows all variants with sample data

**Key Changes**:
- Create components in `src/components/chat/`
- Map reasoning event types to icons/colors (see `web-client/main.py` lines 188-389)
- Use shadcn/ui Accordion for collapsible reasoning

**Testing**:
- Component tests (React Testing Library)
- Visual regression (compare to MonsterUI web client)

**Dependencies**: Milestones 2 (types), 3 (shadcn/ui)

**Risks**: Event type coverage (ensure all types from `api/reasoning_models.py` handled).

---

## Milestone 5: Chat Interface Layout

**Goal**: Build split-pane layout with settings panel and chat area.

**Success Criteria**:
- Split layout: 1/3 settings panel, 2/3 chat
- Chat auto-scrolls to bottom on new messages
- Input form with textarea + Send/Clear buttons
- Settings panel with model selector, temperature/max_tokens sliders, system prompt textarea
- Loading indicator during streaming
- Cancel button enabled during streaming

**Key Changes**:
- Create layout components in `src/components/layout/`
- Create input form in `src/components/forms/MessageInput.tsx`
- Implement auto-scroll with useEffect + ref

**Testing**:
- Component tests (settings update state, input submits on Enter, cancel only enabled when streaming)
- Manual (layout responsive, auto-scroll works)

**Dependencies**: Milestones 3, 4

**Risks**: Auto-scroll timing (may need delay until DOM updates).

---

## Milestone 6: State Management

**Goal**: Implement Zustand store for global state.

**Success Criteria**:
- Store manages: messages, settings, streaming state, reasoning events, current response
- Settings persist to localStorage
- Components consume store (no prop drilling)
- DevTools integration for debugging

**Key Changes**:
- Create `src/store/chat-store.ts` with Zustand
- Define state and actions (addMessage, updateSettings, startStreaming, appendContent, etc.)
- Use persist middleware for settings
- Update components to use store hooks

**Testing**:
- Store unit tests (verify actions update state correctly)
- Integration tests (verify persistence)

**Dependencies**: Milestone 5 (components that consume store)

**Risks**: localStorage can fail in incognito mode.

---

## Milestone 7: API Integration & Streaming

**Goal**: Wire API client to Zustand store and implement full streaming logic.

**Success Criteria**:
- Sending message triggers API call with correct parameters
- Streaming content updates store in real-time
- Reasoning events populate during streaming
- Cancellation aborts stream cleanly
- Error handling shows user-friendly messages

**Key Changes**:
- Create `src/hooks/useChatActions.ts` hook that combines API client + store
- Implement sendMessage with streaming loop
- Implement cancelStreaming with AbortController
- Update MessageInput to use hook

**Testing**:
- Integration tests (mock SSE stream, verify state updates, test cancellation)
- Manual (send message, verify reasoning appears, test cancel mid-stream)

**Dependencies**: Milestones 2, 6

**Risks**: AbortController support, stream cleanup on abort.

---

## Milestone 8: Electron Integration

**Goal**: Configure Electron-specific features (env vars, menu, window state).

**Success Criteria**:
- API base URL configurable via .env (default: http://localhost:8000)
- API token configurable via .env (optional)
- Custom app menu (File/Edit/View/Help)
- Window state persists (size, position)
- Config exposed to renderer via preload script

**Key Changes**:
- Load .env in main process (`electron/config.ts`)
- Expose config to renderer via contextBridge (`electron/preload.ts`)
- Create app menu (`electron/menu.ts`)
- Implement window state persistence (`electron/window-state.ts` using electron-store)

**Testing**: Manual - verify .env config used, menu works, window state persists.

**Dependencies**: Milestones 1, 7

**Risks**: Environment loading in Electron (main vs renderer), file paths in production vs dev.

---

## Milestone 9: Polish & Production Build

**Goal**: Final polish and production build configuration.

**Success Criteria**:
- Error boundaries catch React errors gracefully
- Keyboard accessible (tab navigation, enter to submit)
- Screen reader support (ARIA labels)
- Production build configured with electron-builder
- App icons for macOS/Windows/Linux
- Performance optimizations (lazy loading if needed)

**Key Changes**:
- Add ErrorBoundary component
- Add loading states
- Add ARIA labels to interactive elements
- Configure electron-builder (package.json)
- Create app icons (build/icon.icns, build/icon.ico, build/icon.png)
- Add build scripts (build:mac, build:win, build:linux)

**Testing**:
- Manual (trigger error boundary, keyboard navigation, screen reader, production build)
- Accessibility audit (Lighthouse, axe DevTools)

**Dependencies**: All previous milestones

**Risks**: Icon generation requires platform-specific tools, code signing for macOS.

---

## Milestone 10: Documentation

**Goal**: Create comprehensive docs and update project README.

**Success Criteria**:
- README in desktop-client/ with setup/build/dev instructions
- ARCHITECTURE.md explains component hierarchy and state flow
- Environment variable documentation
- Update root README.md with desktop client info
- Archive web-client/ directory

**Key Changes**:
- Create desktop-client/README.md (quick start, features, config)
- Create desktop-client/ARCHITECTURE.md (tech stack, component tree, data flow)
- Create desktop-client/DEVELOPMENT.md (local dev setup)
- Create desktop-client/DISTRIBUTION.md (build and release)
- Update root README.md
- Move web-client/ to archive/

**Testing**: Verify docs accurate via fresh clone test.

**Dependencies**: All previous milestones

**Risks**: Documentation drift over time.

---

## Post-Implementation Validation

Agent should perform final validation:

1. **End-to-End Test**: Fresh clone ’ follow README ’ build ’ run ’ send message ’ verify UI
2. **Build Verification**: Test installers on macOS/Windows/Linux
3. **Feature Parity**: Compare with MonsterUI web client (streaming, reasoning, settings, cancellation, clear)
4. **Performance**: Test with 100+ messages, verify memory usage reasonable

---

## Success Metrics

Migration complete when:
- All MonsterUI features work in Electron app
- TypeScript strict mode passes, no console errors
- Production builds work on macOS/Windows/Linux
- Complete documentation (README, architecture, dev setup)
- New developers can clone and run in <15 minutes

---

## Notes for Agent

- **Ask before assuming** - clarify unclear requirements
- **Test incrementally** - complete each milestone fully before moving on
- **Quality over speed** - write good tests and docs
- **Breaking changes OK** - no MonsterUI backwards compatibility needed
- **Use modern patterns** - React hooks, TypeScript strict, functional components
- **Stop after each milestone** - wait for human review before proceeding

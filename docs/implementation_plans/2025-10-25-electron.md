# Electron Desktop Client Migration Plan

## Overview

Migrate from MonsterUI/FastHTML web client to Electron desktop app with React + TypeScript + Tailwind CSS + shadcn/ui.

**Why Electron?**
- Developer tool use case (local API, MCP integration, observability)
- Native desktop experience (system integration, file access)
- No hosting/deployment complexity
- Cross-platform from single codebase

**No Backwards Compatibility**: Design the best architecture without MonsterUI constraints. Breaking changes encouraged.

---

## Deployment Model

**Desktop Client (Electron):**
- Runs **natively** on developer's machine (NOT in Docker)
- Distributed as installers (DMG/EXE/AppImage) for end users
- Communicates with API via HTTP (http://localhost:8000 by default)
- Requires Node.js 18+ for **development only** (end users just install the app)

**Backend Services (API, LiteLLM, etc.):**
- Continue running in Docker via `docker-compose.yml`
- No changes to existing Docker setup
- Desktop client is a **consumer** of these services

**Architecture:**
```
Developer's Machine:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Electron App (native)      â”‚
â”‚  npm run dev                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ HTTP
           â–¼
    http://localhost:8000
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Docker Compose Services    â”‚
â”‚  make docker_up             â”‚
â”‚  - reasoning-api            â”‚
â”‚  - litellm                  â”‚
â”‚  - postgres                 â”‚
â”‚  - phoenix                  â”‚
â”‚  - mcp-servers              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Reference Documentation

Agent should review before starting:
- **Electron Docs**: https://www.electronjs.org/docs/latest/tutorial/quick-start
- **shadcn/ui**: https://ui.shadcn.com/docs
- **React SSE Pattern**: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
- **Zustand**: https://docs.pmnd.rs/zustand/getting-started/introduction

---

## Tech Stack

- **Electron**: Desktop wrapper
- **React 18**: UI framework
- **TypeScript**: Type safety (strict mode)
- **Vite**: Build tool (fast, modern)
- **Tailwind CSS**: Utility-first styling
- **shadcn/ui**: Component library (accessible, composable)
- **Zustand**: State management (simpler than Redux)

---

## Prerequisites

**For Desktop Client Development:**
- Node.js 18+ and npm (desktop client runs natively, not in Docker)
- Backend services running via Docker (see below)

**For Backend Services:**
- Docker & Docker Compose (unchanged from current setup)
- Python 3.13+ with uv (for API development)

**Development Workflow:**
```bash
# Terminal 1: Start backend services (Docker)
make docker_up

# Terminal 2: Start desktop client (native Node.js)
cd desktop-client
npm install       # Only needed once
npm run dev       # Starts Electron with hot-reload
```

---

## Milestone 1: Project Scaffolding

**Goal**: Set up Electron + React + TypeScript + Vite with hot reload working.

**Success Criteria**:
- `npm run dev` starts Electron with React hot-reload
- `npm run build` produces distributable app
- TypeScript strict mode enabled
- Tailwind CSS processing works
- Basic "Hello World" renders

**Key Changes**:
- Create `desktop-client/` directory with package.json
- Configure Vite for Electron (base path, output directories)
- Set up Electron main process (window creation, security settings)
- Set up preload script (secure IPC bridge)
- Configure TypeScript (strict mode, React JSX)
- Configure Tailwind CSS

**Testing**: Manual - verify dev mode works, hot reload works, TypeScript catches errors.

**Dependencies**: None

**Risks**: Electron security settings (ensure nodeIntegration: false), Vite config for file:// protocol.

---

## Milestone 2: API Types & HTTP Client

**Goal**: Define type-safe OpenAI-compatible API client with SSE streaming support.

**Success Criteria**:
- TypeScript types match OpenAI API (`ChatCompletionRequest`, `ChatCompletionChunk`, `ReasoningEvent`)
- API client class handles POST to `/v1/chat/completions`
- SSE parser handles `data:` prefix and `[DONE]` signal
- Basic React hook (`useStreamingChat`) manages SSE lifecycle
- Demo component shows streaming working

**Key Changes**:
- Define types in `src/types/openai.ts` (based on `api/models.py`)
- Create API client in `src/lib/api-client.ts` with async generator for streaming
- Create SSE parser in `src/lib/sse-parser.ts`
- Create React hook in `src/hooks/useStreamingChat.ts`

**Testing**:
- Unit tests for SSE parser (valid events, [DONE], malformed JSON)
- Integration tests for hook (mock fetch, verify state updates)
- Manual test with actual API

**Dependencies**: Milestone 1

**Risks**: SSE parsing complexity (ReadableStream API), type alignment with actual API responses.

---

## Milestone 3: UI Component Library

**Goal**: Install shadcn/ui and configure theme.

**Success Criteria**:
- shadcn/ui CLI configured
- Core components installed (Button, Card, Textarea, ScrollArea, Accordion, Separator)
- Theme matches project aesthetic (optional: blue theme like MonsterUI)
- Demo page shows all components working

**Key Changes**:
- Run `npx shadcn-ui@latest init`
- Install components via CLI
- Customize Tailwind config (colors for reasoning events: blue/purple/orange/green)
- Create demo page showing all variants

**Testing**: Manual - visual verification, keyboard navigation, accessibility check.

**Dependencies**: Milestone 1 (Tailwind must be set up)

**Risks**: Path aliases (@/*) must be configured in tsconfig and vite.config.

---

## Milestone 4: Chat Message Components

**Goal**: Build React components for messages, reasoning steps, streaming indicator.

**Success Criteria**:
- `ChatMessage` component renders user/assistant/system messages
- `ReasoningStep` component displays reasoning events with type-specific icons/colors
- `ReasoningAccordion` shows collapsible reasoning tree
- `StreamingIndicator` shows blinking cursor
- Demo page shows all variants with sample data

**Key Changes**:
- Create components in `src/components/chat/`
- Map reasoning event types to icons/colors (see `web-client/main.py` lines 188-389)
- Use shadcn/ui Accordion for collapsible reasoning

**Testing**:
- Component tests (React Testing Library)
- Visual regression (compare to MonsterUI web client)

**Dependencies**: Milestones 2 (types), 3 (shadcn/ui)

**Risks**: Event type coverage (ensure all types from `api/reasoning_models.py` handled).

---

## Milestone 5: Chat Interface Layout

**Goal**: Build split-pane layout with settings panel and chat area.

**Success Criteria**:
- Split layout: 1/3 settings panel, 2/3 chat
- Chat auto-scrolls to bottom on new messages
- Input form with textarea + Send/Clear buttons
- Settings panel with model selector, temperature/max_tokens sliders, system prompt textarea
- Loading indicator during streaming
- Cancel button enabled during streaming

**Key Changes**:
- Create layout components in `src/components/layout/`
- Create input form in `src/components/forms/MessageInput.tsx`
- Implement auto-scroll with useEffect + ref

**Testing**:
- Component tests (settings update state, input submits on Enter, cancel only enabled when streaming)
- Manual (layout responsive, auto-scroll works)

**Dependencies**: Milestones 3, 4

**Risks**: Auto-scroll timing (may need delay until DOM updates).

---

## Milestone 6: State Management

**Goal**: Implement Zustand store for global state with backend conversation storage integration.

**Success Criteria**:
- Store manages: conversation_id, settings, streaming state, reasoning events, current response
- Settings persist to localStorage
- Conversations persist to backend postgres (via API)
- Components consume store (no prop drilling)
- DevTools integration for debugging

**Key Changes**:
- Create `src/store/chat-store.ts` with Zustand
- Define state and actions:
  - `conversation_id: string | null` - Current conversation
  - `settings: ChatSettings` - User preferences (persisted to localStorage)
  - `updateSettings`, `startStreaming`, `appendContent`, etc.
  - **Note**: Messages NOT stored in Zustand (backend manages conversation history)
- Use persist middleware for settings only (not messages)
- Update components to use store hooks

**Backend Dependency**:
- **BLOCKS ON**: Backend conversation storage (Milestone 3 complete)
- Desktop client does not manage message history
- Backend API manages conversations via postgres
- Store only tracks `conversation_id` to identify current conversation

**Testing**:
- Store unit tests (verify actions update state correctly)
- Integration tests with mock conversation API
- Test conversation_id persistence

**Dependencies**:
- Milestone 5 (components that consume store)
- **Backend conversation storage Milestone 3** (API endpoints ready)

**Risks**:
- Backend API downtime (handle gracefully with error states)
- Conversation loading latency (show loading spinner)

---

## Milestone 7: API Integration & Streaming

**Goal**: Wire API client to Zustand store and implement full streaming logic with conversation storage.

**Success Criteria**:
- Sending message triggers API call with correct parameters
- Request includes `conversation_id` if set (stateful mode)
- Request has NO system message (opts into backend conversation storage)
- Streaming content displays in real-time
- Reasoning events populate during streaming
- `conversation_id` extracted from first chunk metadata and stored
- Cancellation aborts stream cleanly
- Error handling shows user-friendly messages

**Key Changes**:
- Create `src/hooks/useChatActions.ts` hook that combines API client + store
- Implement `sendMessage()`:
  - Get `conversation_id` from store (null for new conversations)
  - Build request with only user message (no system message)
  - Include `conversation_id` in request if set
  - Stream response, extract `conversation_id` from first chunk metadata
  - Store `conversation_id` in Zustand for next request
- Implement `cancelStreaming()` with AbortController
- Implement `newConversation()` to clear `conversation_id`
- Update MessageInput to use hook

**Conversation Flow**:
```typescript
// First message (no conversation_id yet)
sendMessage("Hello")
â†’ POST /v1/chat/completions { messages: [{"role": "user", "content": "Hello"}] }
â† Response includes conversation_id in first chunk metadata
â†’ Store conversation_id in Zustand

// Second message (has conversation_id)
sendMessage("Follow-up question")
â†’ POST /v1/chat/completions {
    conversation_id: "uuid",
    messages: [{"role": "user", "content": "Follow-up question"}]
  }
â† Backend loads history + appends new message
```

**Testing**:
- Integration tests with mock conversation API
- Test new conversation creation (no conversation_id)
- Test continuing conversation (with conversation_id)
- Test conversation_id extraction from stream
- Test cancellation mid-stream
- Manual testing with real backend

**Dependencies**:
- Milestones 2, 6
- **Backend conversation storage Milestone 3** (stateful mode working)

**Risks**:
- conversation_id extraction from SSE stream (first chunk timing)
- Backend API errors (handle 404 conversation not found)

---

## Milestone 8: Electron Integration

**Goal**: Configure Electron-specific features (env vars, menu, window state).

**Success Criteria**:
- API base URL configurable via .env (default: http://localhost:8000)
- API token configurable via .env (optional)
- Custom app menu (File/Edit/View/Help)
- Window state persists (size, position)
- Config exposed to renderer via preload script

**Key Changes**:
- Load .env in main process (`electron/config.ts`)
- Expose config to renderer via contextBridge (`electron/preload.ts`)
- Create app menu (`electron/menu.ts`)
- Implement window state persistence (`electron/window-state.ts` using electron-store)

**Testing**: Manual - verify .env config used, menu works, window state persists.

**Dependencies**: Milestones 1, 7

**Risks**: Environment loading in Electron (main vs renderer), file paths in production vs dev.

---

## Milestone 9: Conversation Management UI

**Goal**: Add UI for managing conversations (list, delete, search, new conversation).

**Success Criteria**:
- Conversation list sidebar showing recent conversations
- "New Conversation" button clears current conversation_id
- Delete conversation functionality (with confirmation)
- Click conversation in list to load it
- Visual indicator for current conversation
- Empty state when no conversations exist

**Key Changes**:
- Create `src/components/conversations/ConversationList.tsx`
- Create `src/components/conversations/ConversationItem.tsx`
- Add sidebar layout (toggle-able or always visible)
- Fetch conversations from `GET /v1/conversations` on app load
- Implement "New Conversation" action (clears conversation_id)
- Implement delete conversation (calls `DELETE /v1/conversations/{id}`)
- Implement load conversation (fetches `GET /v1/conversations/{id}`, displays messages)
- Auto-generate conversation titles from first message (or use backend title)

**UI Layout**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Conversations â”‚ Chat              â”‚
â”‚               â”‚                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ â”‚ Conv 1    â”‚ â”‚ â”‚ Message 1       â”‚â”‚
â”‚ â”‚ Conv 2 *  â”‚ â”‚ â”‚ Message 2       â”‚â”‚
â”‚ â”‚ Conv 3    â”‚ â”‚ â”‚ ...             â”‚â”‚
â”‚ â”‚ [+ New]   â”‚ â”‚ â”‚                 â”‚â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚               â”‚ [Input]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
* = current conversation
```

**Testing**:
- Component tests for ConversationList
- Integration tests with mock conversation API
- Manual testing (create, load, delete conversations)

**Dependencies**:
- Milestone 7 (API integration)
- **Backend conversation storage Milestone 4** (conversation management endpoints)

**Risks**:
- Loading full conversation history could be slow (show loading state)
- UX complexity (managing selected vs active conversation)

---

## Milestone 10: Polish & Production Build

**Goal**: Final polish and production build configuration.

**Success Criteria**:
- Error boundaries catch React errors gracefully
- Keyboard accessible (tab navigation, enter to submit)
- Screen reader support (ARIA labels)
- Production build configured with electron-builder
- App icons for macOS/Windows/Linux
- Performance optimizations (lazy loading if needed)
- Copy/export functionality for messages

**Key Changes**:
- Add ErrorBoundary component
- Add loading states
- Add ARIA labels to interactive elements
- Add copy message to clipboard functionality
- Add export conversation (JSON/Markdown)
- Configure electron-builder (package.json)
- Create app icons (build/icon.icns, build/icon.ico, build/icon.png)
- Add build scripts (build:mac, build:win, build:linux)

**Testing**:
- Manual (trigger error boundary, keyboard navigation, screen reader, production build)
- Accessibility audit (Lighthouse, axe DevTools)

**Dependencies**: All previous milestones

**Risks**: Icon generation requires platform-specific tools, code signing for macOS.

---

## Milestone 11: Documentation & Integration

**Goal**: Create comprehensive docs, update Makefile, and integrate with project.

**Success Criteria**:
- README in desktop-client/ with setup/build/dev instructions
- ARCHITECTURE.md explains component hierarchy and state flow
- Makefile updated with desktop client targets
- Root README.md updated with desktop client info
- docker-compose.yml updated (remove web-client service)
- Archive web-client/ directory

**Key Changes**:

**Documentation:**
- Create desktop-client/README.md (quick start, features, config)
- Create desktop-client/ARCHITECTURE.md (tech stack, component tree, data flow)
- Create desktop-client/DEVELOPMENT.md (local dev setup)
- Update root README.md (add Desktop Client section, clarify deployment model)

**Makefile Updates:**
Add these targets to `Makefile`:
```makefile
.PHONY: desktop_client
desktop_client: ## Start desktop client (requires Node.js 18+)
	@echo "ğŸ–¥ï¸  Starting Electron desktop client..."
	@echo "Note: Ensure backend services are running (make docker_up)"
	cd desktop-client && npm install && npm run dev

.PHONY: desktop_build
desktop_build: ## Build desktop client for current platform
	@echo "ğŸ”¨ Building desktop client..."
	cd desktop-client && npm install && npm run build

.PHONY: desktop_test
desktop_test: ## Run desktop client tests
	@echo "ğŸ§ª Running desktop client tests..."
	cd desktop-client && npm test
```

**Docker Compose Updates:**
- Remove `web-client` service from `docker-compose.yml` (replaced by native Electron app)
- Update comments to clarify desktop client runs natively

**Archive Old Web Client:**
```bash
mkdir -p archive
git mv web-client archive/web-client-monsterui
```

**Environment Variables:**
Create `desktop-client/.env.example`:
```bash
# Reasoning API Configuration
REASONING_API_URL=http://localhost:8000
REASONING_API_TOKEN=  # Optional - leave empty if REQUIRE_AUTH=false

# Development
NODE_ENV=development
```

**Testing**:
- Verify Makefile targets work (`make desktop_client`, `make desktop_build`)
- Fresh clone test: follow desktop-client/README.md from scratch
- Verify docker-compose.yml starts without web-client service

**Dependencies**: All previous milestones

**Risks**: Documentation drift over time, developers might not notice web-client removal.

---

## Post-Implementation Validation

Agent should perform final validation:

1. **End-to-End Test**: Fresh clone â†’ follow README â†’ build â†’ run â†’ send message â†’ verify UI
2. **Makefile Integration**: Verify all new targets work (`make desktop_client`, `make desktop_build`, `make desktop_test`)
3. **Docker Compose**: Verify backend services start without web-client service
4. **Feature Parity**: Compare with MonsterUI web client (streaming, reasoning, settings, cancellation, clear)
5. **Performance**: Test with 100+ messages, verify memory usage reasonable
6. **Documentation**: Verify a developer unfamiliar with the project can follow setup instructions successfully

---

## Success Metrics

Migration complete when:
- All MonsterUI features work in Electron app
- TypeScript strict mode passes, no console errors
- Makefile targets work correctly (`make desktop_client` starts app)
- Backend services (Docker) and desktop client (native) work together seamlessly
- Complete documentation (README, architecture, dev setup, Makefile usage)
- New developers can clone and run in <15 minutes
- Old web-client properly archived and removed from docker-compose.yml

---

## Notes for Agent

- **Ask before assuming** - clarify unclear requirements
- **Test incrementally** - complete each milestone fully before moving on
- **Quality over speed** - write good tests and docs
- **Breaking changes OK** - no MonsterUI backwards compatibility needed
- **Use modern patterns** - React hooks, TypeScript strict, functional components
- **Stop after each milestone** - wait for human review before proceeding

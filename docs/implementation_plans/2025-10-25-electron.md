# Electron Desktop Client Migration Plan

## Overview

Migrate from MonsterUI/FastHTML web client to Electron desktop app with React + TypeScript + Tailwind CSS + shadcn/ui.

**Why Electron?**
- Developer tool use case (local API, MCP integration, observability)
- Native desktop experience (system integration, file access)
- No hosting/deployment complexity
- Cross-platform from single codebase

**No Backwards Compatibility**: Design the best architecture without MonsterUI constraints. Breaking changes encouraged.

---

## Deployment Model

**Desktop Client (Electron):**
- Runs **natively** on developer's machine (NOT in Docker)
- Distributed as installers (DMG/EXE/AppImage) for end users
- Communicates with API via HTTP (http://localhost:8000 by default)
- Requires Node.js 18+ for **development only** (end users just install the app)

**Backend Services (API, LiteLLM, etc.):**
- Continue running in Docker via `docker-compose.yml`
- No changes to existing Docker setup
- Desktop client is a **consumer** of these services

**Architecture:**
```
Developer's Machine:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Electron App (native)      â”‚
â”‚  npm run dev                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚ HTTP
           â–¼
    http://localhost:8000
           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Docker Compose Services    â”‚
â”‚  make docker_up             â”‚
â”‚  - reasoning-api            â”‚
â”‚  - litellm                  â”‚
â”‚  - postgres                 â”‚
â”‚  - phoenix                  â”‚
â”‚  - mcp-servers              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Reference Documentation

Agent should review before starting:
- **Electron Docs**: https://www.electronjs.org/docs/latest/tutorial/quick-start
- **shadcn/ui**: https://ui.shadcn.com/docs
- **React SSE Pattern**: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events
- **Zustand**: https://docs.pmnd.rs/zustand/getting-started/introduction

---

## Tech Stack

- **Electron**: Desktop wrapper
- **React 18**: UI framework
- **TypeScript**: Type safety (strict mode)
- **Vite**: Build tool (fast, modern)
- **Tailwind CSS**: Utility-first styling
- **shadcn/ui**: Component library (accessible, composable)
- **Zustand**: State management (simpler than Redux)

---

## Prerequisites

**For Desktop Client Development:**
- Node.js 18+ and npm (desktop client runs natively, not in Docker)
- Backend services running via Docker (see below)

**For Backend Services:**
- Docker & Docker Compose (unchanged from current setup)
- Python 3.13+ with uv (for API development)

**Backend Dependencies:**
- âœ… **LiteLLM Models Proxy**: `GET /v1/models` endpoint ready (dynamic model discovery)
- âœ… **Conversation Storage**: Backend conversation API ready (stateful mode supported)
- âš ï¸ **Conversation Management**: List/delete endpoints needed for Milestone 9

**Development Workflow:**
```bash
# Terminal 1: Start backend services (Docker)
make docker_up

# Terminal 2: Start desktop client (native Node.js)
cd desktop-client
npm install       # Only needed once
npm run dev       # Starts Electron with hot-reload
```

---

## Milestone 1: Project Scaffolding âœ… COMPLETE

**Goal**: Set up Electron + React + TypeScript + Vite with hot reload and test infrastructure.

**Success Criteria**:
- `npm run dev` starts Electron with React hot-reload
- `npm run build` produces distributable app
- `npm test` runs test suite (Jest + React Testing Library)
- TypeScript strict mode enabled
- Tailwind CSS processing works
- Basic "Hello World" renders
- Basic smoke test passes (App renders without crashing)

**Key Changes**:
- Create `desktop-client/` directory with package.json
- Configure Vite for Electron (base path, output directories)
- Set up Electron main process (window creation, security settings)
- Set up preload script (secure IPC bridge)
- Configure TypeScript (strict mode, React JSX)
- Configure Tailwind CSS
- Install Jest + React Testing Library + @testing-library/react
- Configure test scripts in package.json
- Add basic smoke test

**Testing**: Manual - verify dev mode works, hot reload works, TypeScript catches errors. Automated - smoke test passes.

**Dependencies**: None

**Risks**: Electron security settings (ensure nodeIntegration: false), Vite config for file:// protocol.

---

## Milestone 2: API Types & HTTP Client âœ… COMPLETE

**Goal**: Define type-safe OpenAI-compatible API client with SSE streaming support.

**Success Criteria**:
- TypeScript types match OpenAI API (`ChatCompletionRequest`, `ChatCompletionChunk`, `ReasoningEvent`)
- API client class handles POST to `/v1/chat/completions`
- SSE parser handles `data:` prefix and `[DONE]` signal
- Basic React hook (`useStreamingChat`) manages SSE lifecycle
- Demo component shows streaming working

**Key Changes**:
- Define types in `src/types/openai.ts` (based on `api/models.py`)
- Create API client in `src/lib/api-client.ts` with async generator for streaming
- Create SSE parser in `src/lib/sse-parser.ts`
- Create React hook in `src/hooks/useStreamingChat.ts`

**Testing**:
- Unit tests for SSE parser (valid events, [DONE], malformed JSON)
- Integration tests for hook (mock fetch, verify state updates)
- Manual test with actual API
- Focus on critical paths (incremental testing approach)

**Dependencies**: Milestone 1

**Risks**: SSE parsing complexity (ReadableStream API), type alignment with actual API responses.

---

## Milestone 3: UI Component Library âœ… COMPLETE

**Goal**: Install shadcn/ui and configure theme.

**Success Criteria**:
- shadcn/ui CLI configured
- Core components installed (Button, Card, Textarea, ScrollArea, Accordion, Separator)
- Theme matches project aesthetic (optional: blue theme like MonsterUI)
- Demo page shows all components working

**Key Changes**:
- Run `npx shadcn-ui@latest init`
- Install components via CLI
- Customize Tailwind config (colors for reasoning events: blue/purple/orange/green)
- Create demo page showing all variants

**Testing**: Manual - visual verification, keyboard navigation, accessibility check.

**Dependencies**: Milestone 1 (Tailwind must be set up)

**Risks**: Path aliases (@/*) must be configured in tsconfig and vite.config.

---

## Milestone 4: Chat Message Components âœ… COMPLETE

**Goal**: Build React components for messages, reasoning steps, streaming indicator.

**Success Criteria**:
- `ChatMessage` component renders user/assistant/system messages
- `ReasoningStep` component displays reasoning events with type-specific icons/colors
- `ReasoningAccordion` shows collapsible reasoning tree
- `StreamingIndicator` shows blinking cursor
- Demo page shows all variants with sample data

**Key Changes**:
- Create components in `src/components/chat/`
- Map reasoning event types to icons/colors (see `web-client/main.py` lines 188-389)
- Use shadcn/ui Accordion for collapsible reasoning

**Testing**:
- Component tests for key components (React Testing Library)
- Visual regression (compare to MonsterUI web client)
- Focus on critical paths (incremental testing approach)

**Dependencies**: Milestones 2 (types), 3 (shadcn/ui)

**Risks**: Event type coverage (ensure all types from `api/reasoning_models.py` handled).

---

## Milestone 5: Chat Interface Layout âœ… COMPLETE

**Goal**: Build split-pane layout with settings panel, routing controls, and chat area.

**Success Criteria**:
- Split layout: 1/3 settings panel, 2/3 chat
- Chat auto-scrolls to bottom on new messages
- Input form with textarea + Send/Clear buttons
- **Routing mode selector** in chat UI (dropdown/segmented control near input):
  - `Passthrough` - Fast, no reasoning (default)
  - `Reasoning` - Show thinking steps
  - `Auto` - Let classifier decide
- Settings panel with:
  - **Dynamic model selector** (fetched from `GET /v1/models`)
  - Temperature/max_tokens sliders
  - System prompt textarea
- Loading indicator during streaming
- Cancel button enabled during streaming

**Key Changes**:
- Create layout components in `src/components/layout/`
- Create input form in `src/components/forms/MessageInput.tsx`
- Create routing mode selector component
- Fetch models from API on startup, store in state
- Send routing mode via `X-Routing-Mode` header
- Implement auto-scroll with useEffect + ref

**Testing**:
- Component tests (settings update state, input submits on Enter, cancel only enabled when streaming)
- Test routing mode changes send correct headers
- Test model list fetched and rendered
- Manual (layout responsive, auto-scroll works)

**Dependencies**: Milestones 3, 4; Backend `GET /v1/models` endpoint (ready)

**Risks**: Auto-scroll timing (may need delay until DOM updates). API unavailable for models (show defaults).

---

## Milestone 6: State Management âœ… COMPLETE

**Goal**: Implement Zustand store for global state with backend conversation storage integration.

**Success Criteria**:
- Store manages: conversation_id, settings, streaming state, reasoning events, current response
- Settings persist to localStorage
- Conversations persist to backend postgres (via API)
- Components consume store (no prop drilling)
- DevTools integration for debugging

**Key Changes**:
- Create `src/store/chat-store.ts` with Zustand
- Define state and actions:
  - `conversation_id: string | null` - Current conversation
  - `settings: ChatSettings` - User preferences (persisted to localStorage)
  - `updateSettings`, `startStreaming`, `appendContent`, etc.
  - **Note**: Messages NOT stored in Zustand (backend manages conversation history)
- Use persist middleware for settings only (not messages)
- Update components to use store hooks

**Backend Dependency**:
- âœ… **Backend conversation storage ready**
- Desktop client does not manage message history
- Backend API manages conversations via postgres
- Store only tracks `conversation_id` to identify current conversation
- Uses `X-Conversation-ID` header for stateful mode

**Testing**:
- Store unit tests (verify actions update state correctly)
- Integration tests with mock conversation API
- Test conversation_id persistence

**Dependencies**:
- Milestone 5 (components that consume store)
- Backend conversation storage (ready)

**Risks**:
- Backend API downtime (handle gracefully with error states)
- Conversation loading latency (show loading spinner)

---

## Milestone 7: API Integration & Streaming âœ… COMPLETE

**Goal**: Wire API client to Zustand store and implement full streaming logic with conversation storage.

**Success Criteria**:
- Sending message triggers API call with correct parameters
- Request includes `X-Conversation-ID` header for stateful mode
- System message included when user configures it in settings
- Streaming content displays in real-time
- Reasoning events populate during streaming
- `conversation_id` extracted from `X-Conversation-ID` response header and stored
- Cancellation aborts stream cleanly
- Error handling shows user-friendly messages

**Key Changes**:
- Create `src/hooks/useStreamingChat.ts` hook that combines API client + store
- Implement `sendMessage()`:
  - Get `conversation_id` from store (null for new conversations)
  - Build request with user message and optional system message from settings
  - Send `X-Conversation-ID` header with current conversation_id (or "null" for new)
  - Stream response, extract `conversation_id` from `X-Conversation-ID` response header
  - Store `conversation_id` in Zustand for subsequent requests
- Implement `cancelStreaming()` with AbortController
- Implement `newConversation()` to clear `conversation_id`
- Update components to use hook

**Conversation Flow**:
```typescript
// First message (no conversation_id yet)
sendMessage("Hello")
â†’ POST /v1/chat/completions
  Headers: { X-Conversation-ID: "null" }
  Body: { messages: [
    {"role": "system", "content": "..."}, // Optional, from settings
    {"role": "user", "content": "Hello"}
  ]}
â† Response headers: { X-Conversation-ID: "uuid-123" }
â†’ Store conversation_id in Zustand

// Second message (has conversation_id)
sendMessage("Follow-up question")
â†’ POST /v1/chat/completions
  Headers: { X-Conversation-ID: "uuid-123" }
  Body: { messages: [
    {"role": "system", "content": "..."}, // Optional, from settings
    {"role": "user", "content": "Follow-up question"}
  ]}
â† Backend loads history from postgres + appends new message
```

**Stateful vs Stateless Mode**:
- **New conversation**: Send `X-Conversation-ID: "null"` â†’ backend creates new conversation, returns ID in response header
- **Continue conversation**: Send `X-Conversation-ID: <uuid>` â†’ backend loads history and continues
- **System messages**: Optional, controlled by user settings, sent with every request when configured

**Testing**:
- Integration tests with mock conversation API
- Test new conversation creation (no conversation_id)
- Test continuing conversation (with conversation_id)
- Test conversation_id extraction from stream
- Test cancellation mid-stream
- Manual testing with real backend

**Dependencies**:
- Milestones 2, 6
- Backend conversation storage (ready)

**Risks**:
- conversation_id from `X-Conversation-ID` response header (verify extraction)
- Backend API errors (handle 404 conversation not found gracefully)

---

## Milestone 8: Electron Integration âš ï¸ PARTIALLY COMPLETE

**Goal**: Configure Electron-specific features (env vars, auth, menu, window state).

**Status**: Core features done (env vars, auth, security). Polish items pending (menu, window state persistence).

**Success Criteria**:
- âœ… API base URL configurable via .env (default: http://localhost:8000)
- âœ… **Optional API token** via `REASONING_API_TOKEN` in .env
  - If set: send as `Authorization: Bearer {token}` header
  - If empty/unset: no Authorization header (works when backend `REQUIRE_AUTH=false`)
- âœ… Config exposed to renderer via preload script
- âœ… Proper security settings (nodeIntegration: false, contextIsolation: true, sandbox: true)
- â³ Custom app menu (File/Edit/View/Help) - **PENDING**
- â³ Window state persists (size, position) - **PENDING**

**Key Changes**:
- Load .env in main process (`electron/config.ts`)
- Expose config to renderer via contextBridge (`electron/preload.ts`)
- Add optional bearer token to API client requests
- Create app menu (`electron/menu.ts`)
- Implement window state persistence (`electron/window-state.ts` using electron-store)

**Environment Variables** (create `.env.example`):
```bash
# Reasoning API Configuration
REASONING_API_URL=http://localhost:8000
REASONING_API_TOKEN=  # Optional - leave empty if backend REQUIRE_AUTH=false

# Development
NODE_ENV=development
```

**Testing**: Manual - verify .env config used, auth header sent when token set, menu works, window state persists.

**Dependencies**: Milestones 1, 7

**Risks**: Environment loading in Electron (main vs renderer), file paths in production vs dev.

---

## Milestone 9: Conversation Management UI

**Goal**: Add UI for managing conversations (list, delete, search, new conversation).

**Success Criteria**:
- Conversation list sidebar showing recent conversations
- "New Conversation" button clears current conversation_id
- Delete conversation functionality (with confirmation)
- Click conversation in list to load it
- Visual indicator for current conversation
- Empty state when no conversations exist

**Key Changes**:
- Create `src/components/conversations/ConversationList.tsx`
- Create `src/components/conversations/ConversationItem.tsx`
- Add sidebar layout (toggle-able or always visible)
- Fetch conversations from `GET /v1/conversations` on app load
- Implement "New Conversation" action (clears conversation_id)
- Implement delete conversation (calls `DELETE /v1/conversations/{id}`)
- Implement load conversation (fetches `GET /v1/conversations/{id}`, displays messages)
- Auto-generate conversation titles from first message (or use backend title)

**UI Layout**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Conversations â”‚ Chat              â”‚
â”‚               â”‚                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ â”‚ Conv 1    â”‚ â”‚ â”‚ Message 1       â”‚â”‚
â”‚ â”‚ Conv 2 *  â”‚ â”‚ â”‚ Message 2       â”‚â”‚
â”‚ â”‚ Conv 3    â”‚ â”‚ â”‚ ...             â”‚â”‚
â”‚ â”‚ [+ New]   â”‚ â”‚ â”‚                 â”‚â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚               â”‚ [Input]             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
* = current conversation
```

**Testing**:
- Component tests for ConversationList
- Integration tests with mock conversation API
- Manual testing (create, load, delete conversations)

**Dependencies**:
- Milestone 7 (API integration)
- âš ï¸ **Backend conversation management endpoints** (needs implementation):
  - `GET /v1/conversations` - List conversations
  - `GET /v1/conversations/{id}` - Get specific conversation
  - `DELETE /v1/conversations/{id}` - Delete conversation
  - See separate request for backend team

**Risks**:
- Loading full conversation history could be slow (show loading state)
- UX complexity (managing selected vs active conversation)

---

## Milestone 10: Polish & Production Build

**Goal**: Final polish, comprehensive testing, and production build configuration.

**Success Criteria**:
- Error boundaries catch React errors gracefully
- **Orchestration 501 error handled gracefully**:
  - User-friendly error message when orchestration returns 501
  - Suggest using `passthrough` or `reasoning` mode instead
  - No raw error JSON shown
- Keyboard accessible (tab navigation, enter to submit)
- Screen reader support (ARIA labels)
- **Copy/export functionality**:
  - Copy individual messages to clipboard
  - Export conversation as markdown/JSON
- Production build configured with electron-builder
- App icons for macOS/Windows/Linux
- Performance optimizations (lazy loading if needed)
- **Comprehensive test coverage**:
  - Fill coverage gaps from earlier milestones
  - Edge case tests
  - Accessibility tests
  - Performance tests (100+ messages)

**Key Changes**:
- Add ErrorBoundary component
- Add graceful 501 orchestration error handling
- Add loading states
- Add ARIA labels to interactive elements
- Add copy message to clipboard functionality
- Add export conversation (JSON/Markdown)
- Fill test coverage gaps
- Add edge case and accessibility tests
- Configure electron-builder (package.json)
- Create app icons (build/icon.icns, build/icon.ico, build/icon.png)
- Add build scripts (build:mac, build:win, build:linux)

**Testing**:
- Automated: Fill coverage gaps, edge cases, accessibility tests, performance tests
- Manual: Trigger error boundary, keyboard navigation, screen reader, production build
- Accessibility audit (Lighthouse, axe DevTools)

**Dependencies**: All previous milestones

**Risks**: Icon generation requires platform-specific tools, code signing for macOS.

---

## Milestone 11: Documentation & Integration

**Goal**: Create comprehensive docs, update Makefile, and integrate with project.

**Success Criteria**:
- README in desktop-client/ with setup/build/dev instructions
- ARCHITECTURE.md explains component hierarchy and state flow
- Makefile updated with desktop client targets
- Root README.md updated with desktop client info
- docker-compose.yml updated (remove web-client service)
- Archive web-client/ directory

**Key Changes**:

**Documentation:**
- Create desktop-client/README.md (quick start, features, config)
- Create desktop-client/ARCHITECTURE.md (tech stack, component tree, data flow)
- Create desktop-client/DEVELOPMENT.md (local dev setup)
- Update root README.md (add Desktop Client section, clarify deployment model)

**Makefile Updates:**
Add these targets to `Makefile`:
```makefile
.PHONY: desktop_client
desktop_client: ## Start desktop client (requires Node.js 18+)
	@echo "ğŸ–¥ï¸  Starting Electron desktop client..."
	@echo "Note: Ensure backend services are running (make docker_up)"
	cd desktop-client && npm install && npm run dev

.PHONY: desktop_build
desktop_build: ## Build desktop client for current platform
	@echo "ğŸ”¨ Building desktop client..."
	cd desktop-client && npm install && npm run build

.PHONY: desktop_test
desktop_test: ## Run desktop client tests
	@echo "ğŸ§ª Running desktop client tests..."
	cd desktop-client && npm test
```

**Docker Compose Updates:**
- Remove `web-client` service from `docker-compose.yml` (replaced by native Electron app)
- Update comments to clarify desktop client runs natively

**Archive Old Web Client:**
```bash
mkdir -p archive
git mv web-client archive/web-client-monsterui
```

**Testing**:
- Verify Makefile targets work (`make desktop_client`, `make desktop_build`)
- Fresh clone test: follow desktop-client/README.md from scratch
- Verify docker-compose.yml starts without web-client service

**Dependencies**: All previous milestones

**Risks**: Documentation drift over time, developers might not notice web-client removal.

---

## Post-Implementation Validation

Agent should perform final validation:

1. **End-to-End Test**: Fresh clone â†’ follow README â†’ build â†’ run â†’ send message â†’ verify UI
2. **Makefile Integration**: Verify all new targets work (`make desktop_client`, `make desktop_build`, `make desktop_test`)
3. **Docker Compose**: Verify backend services start without web-client service
4. **Feature Parity**: Compare with MonsterUI web client (streaming, reasoning, settings, cancellation, clear)
5. **Performance**: Test with 100+ messages, verify memory usage reasonable
6. **Documentation**: Verify a developer unfamiliar with the project can follow setup instructions successfully

---

## Success Metrics

Migration complete when:
- All MonsterUI features work in Electron app
- TypeScript strict mode passes, no console errors
- Makefile targets work correctly (`make desktop_client` starts app)
- Backend services (Docker) and desktop client (native) work together seamlessly
- Complete documentation (README, architecture, dev setup, Makefile usage)
- New developers can clone and run in <15 minutes
- Old web-client properly archived and removed from docker-compose.yml

---

## Notes for Agent

- **Ask before assuming** - clarify unclear requirements
- **Test incrementally** - complete each milestone fully before moving on
- **Quality over speed** - write good tests and docs
- **Breaking changes OK** - no MonsterUI backwards compatibility needed
- **Use modern patterns** - React hooks, TypeScript strict, functional components
- **Stop after each milestone** - wait for human review before proceeding
